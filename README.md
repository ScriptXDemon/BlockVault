<div align="center">

# BlockVault

Decentralized, ZK‚Äëattestable compressed file anchoring on Ethereum + IPFS.

**Status**: Phase 1 (decentralized storage + Zstandard compression) COMPLETE ‚úÖ ¬∑ Phase 2 (ZK Attested Compression ‚Äì ZKAC) IN PROGRESS ‚öôÔ∏è

</div>

## High‚ÄëLevel Overview

BlockVault eliminates the centralized backend: the browser handles hashing, Zstandard compression (WASM), IPFS upload, and smart‚Äëcontract anchoring. Phase 2 adds a Circom/SNARK proof that a committed compressed blob corresponds to an original file (attesting size/root relationships) before accepting registry entries.

| Layer | Responsibility |
| ----- | -------------- |
| Browser (TS/React) | File chunking, Merkle root, keccak256, Zstd compression, proof generation (snarkjs), wallet tx signing |
| IPFS / Pinning | Stores compressed artifact (content addressed) |
| Solidity `VaultRegistry` | Maps user + (file hash or root) ‚Üí CID; optional ZKAC gate (`registerVerifiablyCompressedFile`) |
| Circom Circuit | Constrains original Merkle root, compressed size relations (placeholder scaffold now) |
| Verifier Contract | On‚Äëchain Groth16 verifier (auto‚Äëgenerated) |

## Current Phases

### Phase 1 (Complete)
Minimal registry + client compression / upload / anchoring with `addFile(bytes32 hash, string cid)`.

### Phase 2 (In Progress ‚Äì ZK Attested Compression)
Adds path: `registerVerifiablyCompressedFile(rootO, cidC, proof, publicSignals)` requiring a Groth16 proof. Circuit scaffold (`circuits/compression.circom`) and setup script (`scripts/zkac_setup.sh`) are present. Frontend module `ZKACRegister.tsx` demonstrates the pending UX.

## Repository Structure (Active Components)

```
contracts/            # VaultRegistry.sol + Verifier.sol (placeholder until snarkjs generates)
circuits/             # compression.circom (scaffold)
scripts/              # zkac_setup.sh (Powers of Tau + Groth16 helper)
blockvault-frontend/  # React client (Phase 1 + Phase 2 WIP modules)
```

Legacy Flask backend code has been deleted; historical copies live in Git history.

## Smart Contracts

### VaultRegistry.sol (excerpt)
```solidity
function addFile(bytes32 fileHash, string calldata cid) external;
function registerVerifiablyCompressedFile(
  bytes32 rootO,
  string calldata cidC,
  uint[2] memory a,
  uint[2][2] memory b,
  uint[2] memory c,
  uint[] memory input
) external; // verifies proof then stores
```

### Verifier.sol
Generated by `snarkjs zkey export solidityverifier`. The placeholder should be replaced after running setup (below).

## ZKAC Circuit Workflow

1. Define/extend constraints in `circuits/compression.circom` (currently a minimal scaffold). 
2. Run trusted setup script (Powers of Tau + Groth16):
   ```bash
   bash scripts/zkac_setup.sh
   ```
   Outputs (example paths):
   - `build/compression.r1cs`
   - `build/compression_js/compression.wasm`
   - `build/compression_final.zkey`
   - `build/verification_key.json`
   - `contracts/Verifier.sol` (overwritten with generated verifier)
3. Deploy `Verifier.sol` then deploy `VaultRegistry` with constructor param = verifier address.
4. Copy artifacts for frontend:
   ```bash
   cp build/compression_js/compression.wasm blockvault-frontend/public/zkac/
   cp build/compression_final.zkey blockvault-frontend/public/zkac/compression.zkey
   ```
5. Frontend generates proof via `snarkjs.groth16.fullProve` (see `src/lib/snarkjs.ts`).
6. Submit proof & signals to `registerVerifiablyCompressedFile`.

## Frontend Setup

```bash
cd blockvault-frontend
npm install
npm start
```

Environment variables (`.env` in `blockvault-frontend/`):
```
VITE_VAULT_REGISTRY_ADDRESS=0xYourRegistry
VITE_IPFS_API_URL=https://your-ipfs-endpoint/api/v0
VITE_IPFS_API_TOKEN=Bearer <token>
```

## Phase 1 Upload Flow (Implemented)
1. User selects file ‚Üí hash with keccak256.
2. Compress using Zstandard WASM (`zstd.ts`).
3. Upload compressed bytes to IPFS ‚Üí CID.
4. Call `addFile(hash, cid)`.
5. Display Tx hash & stored CID.

## Phase 2 Additional Data (Pending Finalization)
The circuit will commit:
| Signal | Meaning |
| ------ | ------- |
| `rootO` | Merkle root of original chunks |
| `original_size` | Uncompressed size |
| `compressed_size` | Compressed size |
| (future) dictionary / window metadata | Ensures deterministic compression statement |

The proof binds these to the on‚Äëchain inputs so users cannot lie about compression ratio or altered content.

## Building & Generating Proof (Dev Example)
```bash
# 1. Generate circuit + verifier
bash scripts/zkac_setup.sh

# 2. (Deploy contracts using your chosen tool ‚Äì Hardhat/Foundry not yet scaffolded here)

# 3. Copy artifacts to frontend public/zkac
mkdir -p blockvault-frontend/public/zkac
cp build/compression_js/compression.wasm blockvault-frontend/public/zkac/
cp build/compression_final.zkey blockvault-frontend/public/zkac/compression.zkey

# 4. Start frontend and use ZKAC UI component (dev route/component integration pending)
cd blockvault-frontend && npm start
```

## Security Considerations
- ZK circuit is a stub: DO NOT rely on current constraints for production trust assumptions.
- Trusted setup must be re-run with multi-party ceremony before production.
- File hash/roots are public; consider future salted commitments for privacy.
- Ensure IPFS pin redundancy (multiple providers or Filecoin deals) for permanence.

## Contributing
Focused help wanted on:
* Circuit design for realistic compression attestation (window size, block checksums)
* Hardhat/Foundry deployment scripts + automated ABI export
* Event indexing & pagination UX
* Progressive streaming decompression

## Roadmap
| Phase | Goal | Status |
| ----- | ---- | ------ |
| 1 | Decentralized upload + Zstd + anchoring | ‚úÖ Complete |
| 2 | ZK attested compression (Groth16) | ‚öôÔ∏è In progress |
| 3 | Zero‚ÄëKnowledge Proof of Transformation (redaction prototype) | üöß Prototype scaffolds |
| 4 | Performance + indexing (offloaded proving, indexer) | üöß In progress |

## License
MIT

---

Happy hacking ‚Äì PRs improving the ZKAC flow or compression circuit especially welcome.

---

### Phase 3 (ZK Proof of Transformation) Notes

Prototype redaction circuit (`circuits/redaction.circom`) added (stub: enforces rootO == rootT currently). Plan:

1. Implement chunk commitment hashing (Poseidon) for original & transformed.
2. Encode redaction intervals and enforce monotonic non‚Äëoverlapping ordering.
3. Reconstruct transformed transcript inside circuit skipping removed ranges; recompute rootT.
4. Expose public signals: rootO, rootT, removed_bytes_count.
5. Replace equality stub with full constraints; re-run trusted setup producing `redaction.wasm` & `redaction.zkey`.
6. Generate verifier (`snarkjs zkey export solidityverifier ... RedactionVerifier.sol`) and wire `setTransformVerifier`.
7. Enable `registerTransformation` client call (currently logged only in `RedactionTransform.tsx`).

Security: Until constraints implemented & audited, transformation proofs are NOT meaningful.

### Phase 4 (Performance & Production Readiness) Notes

Components added:
* `prover-service/` ‚Äì offloads Groth16 proof generation to a CPU (future GPU) server.
* `indexer/` ‚Äì event listener caching `FileAdded` & `TransformationRegistered` for fast user queries.

Planned optimizations:
1. Browser ‚Üí Prover offload with signed job requests (prevent tampering) and job IDs for async polling.
2. Proof recursion / aggregation (batch multiple file proofs into one). Requires new recursive circuit + verifier.
3. Deploy on L2 (e.g., zkSync / Scroll / Polygon zkEVM) to reduce verification gas.
4. Switch hash inside circuits to Poseidon for performance, while keeping keccak client‚Äëside for ecosystem compatibility.
5. Progressive chunk verification: commit large file in subtrees and prove per subtree (streaming integrity).
6. Replace in‚Äëmemory indexer with Postgres + backfill + confirmation depth handling.

User Experience goals:
* Hide cryptographic jargon; surface simple statuses: "Compressing", "Proving", "Anchoring".
* Show optimistic UI entry immediately after upload while proof finalizes.
* Provide cost estimate / gas abstraction (meta‚Äëtransactions or paymaster on L2).

Security / Integrity:
* Sign proving job payload with user wallet to prevent server substituting roots.
* Include hash of WASM + zkey in job ‚Üí allow client to verify server used expected artifacts.
* Add rate limiting & auth (API key / JWT) to prover and indexer.
